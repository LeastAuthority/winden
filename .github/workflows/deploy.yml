---
name: Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Deploy target environment"
        type: choice
        options:
          - stage
          - prod
        required: true
  pull_request:
    branches:
      - main
#  workflow_run:
#    workflows: [transfer-repo-CI]
#    types: [completed]
#    branches: [main]

jobs:
  deploy:
    # `if` required because a workflow run is triggered regardless of
    # the result of the previous workflow (see the documentation page)
    #    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    name: Deploy
    runs-on: ubuntu-22.04
    env:
      TEST_ENV: foobar
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: create variables for production env.
        if: inputs.environment == 'prod'
        run: |
          echo "MAILBOX_URL=wss://mailbox.winden.app/v1" >> $GITHUB_ENV
          echo "RELAY_URL=wss://relay.winden.app/" >> $GITHUB_ENV

      - name: create variables for stage env.
        if: inputs.environment == 'stage'
        run: |
          echo "MAILBOX_URL=wss://mailbox.stage.winden.app/v1" >> $GITHUB_ENV
          echo "RELAY_URL=wss://relay.stage.winden.app/" >> $GITHUB_ENV

      - name: Dump docker version details
        run: |
          docker version
          docker compose version

      - name: create config .env file
        run: |
          touch ./client/.env
          cat <<EOF >> ./client/.env
          MAILBOX_URL="${{ env.MAILBOX_URL }}"
          RELAY_URL="${{ env.RELAY_URL }}"
          SFTP_HOSTNAME=${{ secrets.SFTP_HOSTNAME }}
          SFTP_USERNAME=${{ secrets.SFTP_USERNAME }}
          SFTP_IDENTITY="${{ secrets.SFTP_IDENTITY }}"
          NODE_ENV=production
          ENVIRONMENT=${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'stage' }}
          SUFFIX="${{ github.event.pull_request.number }}"
          EOF
          touch ./client-e2e/.env

      - name: prepare
        id: prepare
        run: |
          docker compose build
          docker compose run client npm install --include=dev
          docker compose run client npm version
          docker compose run client npm list

      - name: deploy
        id: deploy
        run: docker compose run client gulp deploy

      - name: tear down
        id: cleanup
        run: docker compose down

      - name: Update PR with result
        uses: actions/github-script@v6
        if: github.event_name == 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // 1. Retrieve existing bot comments for the PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            })
            const botComment = comments.find(comment => {
              return comment.user.type === 'Bot' && comment.body.includes('Frontend deployment')
            })

            // 2. Prepare format of the comment
            const output = `#### Container setup 🖌 \`${{ steps.prepare.outcome }}\`
            #### Frontend deployment ⚙️\`${{ steps.deploy.outcome }}\`
            #### Cleanup 🧹 \`${{ steps.cleanup.outcome }}\`

            #### [Winden frontend preview](https://stage.winden.app/${{ github.event.pull_request.number }}/)

            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Workflow: \`${{ github.workflow }}\`*`;

            // 3. If we have a comment, update it, otherwise create a new one
            const comment_data = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            }
            if (botComment) {
              comment_data.comment_id = botComment.id
              github.rest.issues.updateComment(comment_data)
            } else {
              comment_data.issue_number = context.issue.number
              github.rest.issues.createComment(comment_data)
            }

